# coding: utf-8

"""
    Snowflake Database API

    The Snowflake Database API is a REST API that you can use to access, update, and perform certain actions on Database resource in Snowflake.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: support@snowflake.com
    Generated by: https://openapi-generator.tech

    Do not edit this file manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Optional
from typing import Union
from snowflake.core.database._generated.pydantic_compatibility import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
from snowflake.core.database._generated.models.point_of_time import PointOfTime

class DatabaseClone(BaseModel):
    point_of_time: Optional[PointOfTime] = None
    created_on: Optional[datetime] = None
    name: constr(strict=True) = Field(...)
    is_default: Optional[StrictBool] = None
    is_current: Optional[StrictBool] = None
    origin: Optional[StrictStr] = None
    owner: Optional[StrictStr] = None
    comment: Optional[StrictStr] = None
    options: Optional[StrictStr] = None
    retention_time: Optional[StrictInt] = None
    dropped_on: Optional[datetime] = None
    kind: Optional[StrictStr] = None
    budget: Optional[StrictStr] = None
    owner_role_type: Optional[StrictStr] = None
    data_retention_time_in_days: Optional[StrictInt] = None
    default_ddl_collation: Optional[StrictStr] = None
    log_level: Optional[StrictStr] = None
    max_data_extension_time_in_days: Optional[StrictInt] = None
    suspend_task_after_num_failures: Optional[StrictInt] = None
    trace_level: Optional[StrictStr] = None
    user_task_managed_initial_warehouse_size: Optional[StrictStr] = None
    user_task_timeout_ms: Optional[StrictInt] = None
    __properties = ["created_on", "name", "is_default", "is_current", "origin", "owner", "comment", "options", "retention_time", "dropped_on", "kind", "budget", "owner_role_type", "data_retention_time_in_days", "default_ddl_collation", "log_level", "max_data_extension_time_in_days", "suspend_task_after_num_failures", "trace_level", "user_task_managed_initial_warehouse_size", "user_task_timeout_ms"]


    @validator('name')
    def name_validate_regular_expression(cls, v):
        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/""")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> DatabaseClone:
        """Create an instance of DatabaseClone from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "created_on",
                            "is_default",
                            "is_current",
                            "origin",
                            "owner",
                            "options",
                            "retention_time",
                            "dropped_on",
                            "kind",
                            "budget",
                            "owner_role_type",
                          },
                          exclude_none=True)
        # set to None if dropped_on (nullable) is None
        if self.dropped_on is None:
            _dict['dropped_on'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> DatabaseClone:
        """Create an instance of DatabaseClone from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return DatabaseClone.parse_obj(obj)

        _obj = DatabaseClone.parse_obj({
            "point_of_time": PointOfTime.from_dict(obj.get("point_of_time")) if obj.get("point_of_time") is not None else None,

            "created_on": obj.get("created_on"),

            "name": obj.get("name"),

            "is_default": obj.get("is_default"),

            "is_current": obj.get("is_current"),

            "origin": obj.get("origin"),

            "owner": obj.get("owner"),

            "comment": obj.get("comment"),

            "options": obj.get("options"),

            "retention_time": obj.get("retention_time"),

            "dropped_on": obj.get("dropped_on"),

            "kind": obj.get("kind"),

            "budget": obj.get("budget"),

            "owner_role_type": obj.get("owner_role_type"),

            "data_retention_time_in_days": obj.get("data_retention_time_in_days"),

            "default_ddl_collation": obj.get("default_ddl_collation"),

            "log_level": obj.get("log_level"),

            "max_data_extension_time_in_days": obj.get("max_data_extension_time_in_days"),

            "suspend_task_after_num_failures": obj.get("suspend_task_after_num_failures"),

            "trace_level": obj.get("trace_level"),

            "user_task_managed_initial_warehouse_size": obj.get("user_task_managed_initial_warehouse_size"),

            "user_task_timeout_ms": obj.get("user_task_timeout_ms"),

        })
        return _obj


from typing import Optional, List, Dict
from snowflake.core.database._generated.models.point_of_time import PointOfTime

class DatabaseCloneModel():
    def __init__(
        self,
        name: str,
        # optional properties
        point_of_time: Optional[PointOfTime] = None,
        created_on: Optional[datetime] = None,
        is_default: Optional[bool] = None,
        is_current: Optional[bool] = None,
        origin: Optional[str] = None,
        owner: Optional[str] = None,
        comment: Optional[str] = None,
        options: Optional[str] = None,
        retention_time: Optional[int] = None,
        dropped_on: Optional[datetime] = None,
        kind: Optional[str] = None,
        budget: Optional[str] = None,
        owner_role_type: Optional[str] = None,
        data_retention_time_in_days: Optional[int] = None,
        default_ddl_collation: Optional[str] = None,
        log_level: Optional[str] = None,
        max_data_extension_time_in_days: Optional[int] = None,
        suspend_task_after_num_failures: Optional[int] = None,
        trace_level: Optional[str] = None,
        user_task_managed_initial_warehouse_size: Optional[str] = None,
        user_task_timeout_ms: Optional[int] = None,
    ):
        self.point_of_time = point_of_time
        self.created_on = created_on
        self.name = name
        self.is_default = is_default
        self.is_current = is_current
        self.origin = origin
        self.owner = owner
        self.comment = comment
        self.options = options
        self.retention_time = retention_time
        self.dropped_on = dropped_on
        self.kind = kind
        self.budget = budget
        self.owner_role_type = owner_role_type
        self.data_retention_time_in_days = data_retention_time_in_days
        self.default_ddl_collation = default_ddl_collation
        self.log_level = log_level
        self.max_data_extension_time_in_days = max_data_extension_time_in_days
        self.suspend_task_after_num_failures = suspend_task_after_num_failures
        self.trace_level = trace_level
        self.user_task_managed_initial_warehouse_size = user_task_managed_initial_warehouse_size
        self.user_task_timeout_ms = user_task_timeout_ms
    __properties = ["created_on", "name", "is_default", "is_current", "origin", "owner", "comment", "options", "retention_time", "dropped_on", "kind", "budget", "owner_role_type", "data_retention_time_in_days", "default_ddl_collation", "log_level", "max_data_extension_time_in_days", "suspend_task_after_num_failures", "trace_level", "user_task_managed_initial_warehouse_size", "user_task_timeout_ms"]

    def _to_model(self):
        return DatabaseClone(
            point_of_time=self.point_of_time._to_model() if self.point_of_time is not None else None,

            created_on=self.created_on,

            name=self.name,

            is_default=self.is_default,

            is_current=self.is_current,

            origin=self.origin,

            owner=self.owner,

            comment=self.comment,

            options=self.options,

            retention_time=self.retention_time,

            dropped_on=self.dropped_on,

            kind=self.kind,

            budget=self.budget,

            owner_role_type=self.owner_role_type,

            data_retention_time_in_days=self.data_retention_time_in_days,

            default_ddl_collation=self.default_ddl_collation,

            log_level=self.log_level,

            max_data_extension_time_in_days=self.max_data_extension_time_in_days,

            suspend_task_after_num_failures=self.suspend_task_after_num_failures,

            trace_level=self.trace_level,

            user_task_managed_initial_warehouse_size=self.user_task_managed_initial_warehouse_size,

            user_task_timeout_ms=self.user_task_timeout_ms,

        )

    @classmethod
    def _from_model(cls, model) -> DatabaseCloneModel:
        return DatabaseCloneModel(
            point_of_time=PointOfTimeModel._from_model(model.point_of_time) if model.point_of_time is not None else None,

            created_on=model.created_on,

            name=model.name,

            is_default=model.is_default,

            is_current=model.is_current,

            origin=model.origin,

            owner=model.owner,

            comment=model.comment,

            options=model.options,

            retention_time=model.retention_time,

            dropped_on=model.dropped_on,

            kind=model.kind,

            budget=model.budget,

            owner_role_type=model.owner_role_type,

            data_retention_time_in_days=model.data_retention_time_in_days,

            default_ddl_collation=model.default_ddl_collation,

            log_level=model.log_level,

            max_data_extension_time_in_days=model.max_data_extension_time_in_days,

            suspend_task_after_num_failures=model.suspend_task_after_num_failures,

            trace_level=model.trace_level,

            user_task_managed_initial_warehouse_size=model.user_task_managed_initial_warehouse_size,

            user_task_timeout_ms=model.user_task_timeout_ms,

        )

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        return self._to_model().to_dict()

    @classmethod
    def from_dict(cls, obj: dict) -> DatabaseCloneModel:
        """Create an instance of DatabaseClone from a dict"""
        return cls._from_model(DatabaseClone.from_dict(obj))


DatabaseClone._model_class = DatabaseCloneModel
