# coding: utf-8

"""
    Snowflake Warehouse API

    The Snowflake Warehouse API is a REST API that you can use to access, customize and manage virtual warehouse in a Snowflake account.  # noqa: E501

    The version of the OpenAPI document: 0.0.1
    Contact: support@snowflake.com
    Generated by: https://openapi-generator.tech

    Do not edit this file manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from typing import Dict, Optional
from typing import Union
from snowflake.core.warehouse._generated.pydantic_compatibility import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator

class Warehouse(BaseModel):
    name: constr(strict=True) = Field(...)
    warehouse_type: Optional[StrictStr] = None
    warehouse_size: Optional[StrictStr] = None
    wait_for_completion: Optional[StrictStr] = None
    max_cluster_count: Optional[StrictInt] = None
    min_cluster_count: Optional[StrictInt] = None
    scaling_policy: Optional[StrictStr] = None
    auto_suspend: Optional[StrictInt] = None
    auto_resume: Optional[StrictStr] = None
    initially_suspended: Optional[StrictStr] = None
    resource_monitor: Optional[constr(strict=True)] = None
    comment: Optional[StrictStr] = None
    enable_query_acceleration: Optional[StrictStr] = None
    query_acceleration_max_scale_factor: Optional[StrictInt] = None
    max_concurrency_level: Optional[StrictInt] = None
    statement_queued_timeout_in_seconds: Optional[StrictInt] = None
    statement_timeout_in_seconds: Optional[StrictInt] = None
    tags: Optional[Dict[str, StrictStr]] = None
    type: Optional[StrictStr] = None
    size: Optional[StrictStr] = None
    state: Optional[StrictStr] = None
    started_clusters: Optional[StrictInt] = None
    running: Optional[StrictInt] = None
    queued: Optional[StrictInt] = None
    is_default: Optional[StrictBool] = None
    is_current: Optional[StrictBool] = None
    available: Optional[StrictStr] = None
    provisioning: Optional[StrictStr] = None
    quiescing: Optional[StrictStr] = None
    other: Optional[StrictStr] = None
    created_on: Optional[datetime] = None
    resumed_on: Optional[datetime] = None
    updated_on: Optional[datetime] = None
    owner: Optional[StrictStr] = None
    budget: Optional[StrictStr] = None
    kind: Optional[StrictStr] = None
    __properties = ["name", "warehouse_type", "warehouse_size", "wait_for_completion", "max_cluster_count", "min_cluster_count", "scaling_policy", "auto_suspend", "auto_resume", "initially_suspended", "resource_monitor", "comment", "enable_query_acceleration", "query_acceleration_max_scale_factor", "max_concurrency_level", "statement_queued_timeout_in_seconds", "statement_timeout_in_seconds", "tags", "type", "size", "state", "started_clusters", "running", "queued", "is_default", "is_current", "available", "provisioning", "quiescing", "other", "created_on", "resumed_on", "updated_on", "owner", "budget", "kind"]


    @validator('name')
    def name_validate_regular_expression(cls, v):
        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/""")
        return v

    @validator('wait_for_completion')
    def wait_for_completion_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('auto_resume')
    def auto_resume_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('initially_suspended')
    def initially_suspended_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    @validator('resource_monitor')
    def resource_monitor_validate_regular_expression(cls, v):
        if v is None:
            return v
        if not re.match(r"""^\"([^\"]|\"\")+\"|[a-zA-Z_][a-zA-Z0-9_$]*$""", v):
            raise ValueError(r"""must validate the regular expression /^"([^"]|"")+"|[a-zA-Z_][a-zA-Z0-9_$]*$/""")
        return v

    @validator('enable_query_acceleration')
    def enable_query_acceleration_validate_enum(cls, v):
        if v is None:
            return v

        if v not in ('true', 'false'):
            raise ValueError("must validate the enum values ('true', 'false')")
        return v

    class Config:
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Warehouse:
        """Create an instance of Warehouse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                            "state",
                            "started_clusters",
                            "running",
                            "queued",
                            "is_default",
                            "is_current",
                            "available",
                            "provisioning",
                            "quiescing",
                            "other",
                            "created_on",
                            "resumed_on",
                            "updated_on",
                            "owner",
                            "budget",
                            "kind",
                          },
                          exclude_none=True)
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Warehouse:
        """Create an instance of Warehouse from a dict"""
        if obj is None:
            return None

        if type(obj) is not dict:
            return Warehouse.parse_obj(obj)

        _obj = Warehouse.parse_obj({
            "name": obj.get("name"),

            "warehouse_type": obj.get("warehouse_type"),

            "warehouse_size": obj.get("warehouse_size"),

            "wait_for_completion": obj.get("wait_for_completion"),

            "max_cluster_count": obj.get("max_cluster_count"),

            "min_cluster_count": obj.get("min_cluster_count"),

            "scaling_policy": obj.get("scaling_policy"),

            "auto_suspend": obj.get("auto_suspend"),

            "auto_resume": obj.get("auto_resume"),

            "initially_suspended": obj.get("initially_suspended"),

            "resource_monitor": obj.get("resource_monitor"),

            "comment": obj.get("comment"),

            "enable_query_acceleration": obj.get("enable_query_acceleration"),

            "query_acceleration_max_scale_factor": obj.get("query_acceleration_max_scale_factor"),

            "max_concurrency_level": obj.get("max_concurrency_level"),

            "statement_queued_timeout_in_seconds": obj.get("statement_queued_timeout_in_seconds"),

            "statement_timeout_in_seconds": obj.get("statement_timeout_in_seconds"),

            "tags": obj.get("tags"),

            "type": obj.get("type"),

            "size": obj.get("size"),

            "state": obj.get("state"),

            "started_clusters": obj.get("started_clusters"),

            "running": obj.get("running"),

            "queued": obj.get("queued"),

            "is_default": obj.get("is_default"),

            "is_current": obj.get("is_current"),

            "available": obj.get("available"),

            "provisioning": obj.get("provisioning"),

            "quiescing": obj.get("quiescing"),

            "other": obj.get("other"),

            "created_on": obj.get("created_on"),

            "resumed_on": obj.get("resumed_on"),

            "updated_on": obj.get("updated_on"),

            "owner": obj.get("owner"),

            "budget": obj.get("budget"),

            "kind": obj.get("kind"),

        })
        return _obj


from typing import Optional, List, Dict

class WarehouseModel():
    def __init__(
        self,
        name: str,
        # optional properties
        warehouse_type: Optional[str] = None,
        warehouse_size: Optional[str] = None,
        wait_for_completion: Optional[str] = None,
        max_cluster_count: Optional[int] = None,
        min_cluster_count: Optional[int] = None,
        scaling_policy: Optional[str] = None,
        auto_suspend: Optional[int] = None,
        auto_resume: Optional[str] = None,
        initially_suspended: Optional[str] = None,
        resource_monitor: Optional[str] = None,
        comment: Optional[str] = None,
        enable_query_acceleration: Optional[str] = None,
        query_acceleration_max_scale_factor: Optional[int] = None,
        max_concurrency_level: Optional[int] = None,
        statement_queued_timeout_in_seconds: Optional[int] = None,
        statement_timeout_in_seconds: Optional[int] = None,
        tags: Optional[str] = None,
        type: Optional[str] = None,
        size: Optional[str] = None,
        state: Optional[str] = None,
        started_clusters: Optional[int] = None,
        running: Optional[int] = None,
        queued: Optional[int] = None,
        is_default: Optional[bool] = None,
        is_current: Optional[bool] = None,
        available: Optional[str] = None,
        provisioning: Optional[str] = None,
        quiescing: Optional[str] = None,
        other: Optional[str] = None,
        created_on: Optional[datetime] = None,
        resumed_on: Optional[datetime] = None,
        updated_on: Optional[datetime] = None,
        owner: Optional[str] = None,
        budget: Optional[str] = None,
        kind: Optional[str] = None,
    ):
        self.name = name
        self.warehouse_type = warehouse_type
        self.warehouse_size = warehouse_size
        self.wait_for_completion = wait_for_completion
        self.max_cluster_count = max_cluster_count
        self.min_cluster_count = min_cluster_count
        self.scaling_policy = scaling_policy
        self.auto_suspend = auto_suspend
        self.auto_resume = auto_resume
        self.initially_suspended = initially_suspended
        self.resource_monitor = resource_monitor
        self.comment = comment
        self.enable_query_acceleration = enable_query_acceleration
        self.query_acceleration_max_scale_factor = query_acceleration_max_scale_factor
        self.max_concurrency_level = max_concurrency_level
        self.statement_queued_timeout_in_seconds = statement_queued_timeout_in_seconds
        self.statement_timeout_in_seconds = statement_timeout_in_seconds
        self.tags = tags
        self.type = type
        self.size = size
        self.state = state
        self.started_clusters = started_clusters
        self.running = running
        self.queued = queued
        self.is_default = is_default
        self.is_current = is_current
        self.available = available
        self.provisioning = provisioning
        self.quiescing = quiescing
        self.other = other
        self.created_on = created_on
        self.resumed_on = resumed_on
        self.updated_on = updated_on
        self.owner = owner
        self.budget = budget
        self.kind = kind
    __properties = ["name", "warehouse_type", "warehouse_size", "wait_for_completion", "max_cluster_count", "min_cluster_count", "scaling_policy", "auto_suspend", "auto_resume", "initially_suspended", "resource_monitor", "comment", "enable_query_acceleration", "query_acceleration_max_scale_factor", "max_concurrency_level", "statement_queued_timeout_in_seconds", "statement_timeout_in_seconds", "tags", "type", "size", "state", "started_clusters", "running", "queued", "is_default", "is_current", "available", "provisioning", "quiescing", "other", "created_on", "resumed_on", "updated_on", "owner", "budget", "kind"]

    def _to_model(self):
        return Warehouse(
            name=self.name,

            warehouse_type=self.warehouse_type,

            warehouse_size=self.warehouse_size,

            wait_for_completion=self.wait_for_completion,

            max_cluster_count=self.max_cluster_count,

            min_cluster_count=self.min_cluster_count,

            scaling_policy=self.scaling_policy,

            auto_suspend=self.auto_suspend,

            auto_resume=self.auto_resume,

            initially_suspended=self.initially_suspended,

            resource_monitor=self.resource_monitor,

            comment=self.comment,

            enable_query_acceleration=self.enable_query_acceleration,

            query_acceleration_max_scale_factor=self.query_acceleration_max_scale_factor,

            max_concurrency_level=self.max_concurrency_level,

            statement_queued_timeout_in_seconds=self.statement_queued_timeout_in_seconds,

            statement_timeout_in_seconds=self.statement_timeout_in_seconds,

            tags=self.tags,

            type=self.type,

            size=self.size,

            state=self.state,

            started_clusters=self.started_clusters,

            running=self.running,

            queued=self.queued,

            is_default=self.is_default,

            is_current=self.is_current,

            available=self.available,

            provisioning=self.provisioning,

            quiescing=self.quiescing,

            other=self.other,

            created_on=self.created_on,

            resumed_on=self.resumed_on,

            updated_on=self.updated_on,

            owner=self.owner,

            budget=self.budget,

            kind=self.kind,

        )

    @classmethod
    def _from_model(cls, model) -> WarehouseModel:
        return WarehouseModel(
            name=model.name,

            warehouse_type=model.warehouse_type,

            warehouse_size=model.warehouse_size,

            wait_for_completion=model.wait_for_completion,

            max_cluster_count=model.max_cluster_count,

            min_cluster_count=model.min_cluster_count,

            scaling_policy=model.scaling_policy,

            auto_suspend=model.auto_suspend,

            auto_resume=model.auto_resume,

            initially_suspended=model.initially_suspended,

            resource_monitor=model.resource_monitor,

            comment=model.comment,

            enable_query_acceleration=model.enable_query_acceleration,

            query_acceleration_max_scale_factor=model.query_acceleration_max_scale_factor,

            max_concurrency_level=model.max_concurrency_level,

            statement_queued_timeout_in_seconds=model.statement_queued_timeout_in_seconds,

            statement_timeout_in_seconds=model.statement_timeout_in_seconds,

            tags=model.tags,

            type=model.type,

            size=model.size,

            state=model.state,

            started_clusters=model.started_clusters,

            running=model.running,

            queued=model.queued,

            is_default=model.is_default,

            is_current=model.is_current,

            available=model.available,

            provisioning=model.provisioning,

            quiescing=model.quiescing,

            other=model.other,

            created_on=model.created_on,

            resumed_on=model.resumed_on,

            updated_on=model.updated_on,

            owner=model.owner,

            budget=model.budget,

            kind=model.kind,

        )

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        return self._to_model().to_dict()

    @classmethod
    def from_dict(cls, obj: dict) -> WarehouseModel:
        """Create an instance of Warehouse from a dict"""
        return cls._from_model(Warehouse.from_dict(obj))


Warehouse._model_class = WarehouseModel
